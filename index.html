<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Srpski_Cas Mini App</title>
  <style>
    .hidden { display: none !important; }
  </style>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="styles.css?v=20260210-14" />
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
  <main class="app">
    <header class="app-bar">
      <div class="app-brand">
        <img class="brand-logo" src="assets/logo.png" alt="Srpski_Cas" />
      </div>
    </header>

    <div class="progress" id="progress">
      <span id="sceneLabel">A1</span>
      <span id="cardCounter">0/0</span>
    </div>

    <section class="panel" id="gate">
      <h1 id="gateTitle"></h1>
      <p class="lead" id="gateLead"></p>
      <button class="btn primary" id="startBtn" type="button" disabled>Start</button>
      <div class="hint" id="startHint"></div>
    </section>

    <section class="panel hidden" id="trainer">
      <div class="phrase" id="ruText"></div>
      <button class="btn play" id="playBtn" type="button"></button>
      <button class="btn ghost" id="revealBtn" type="button"></button>
      <div class="answer hidden" id="srText"></div>
      <div class="grades hidden" id="grades">
        <button class="grade hard" data-grade="hard" id="gradeHard" type="button"></button>
        <button class="grade good" data-grade="good" id="gradeGood" type="button"></button>
        <button class="grade easy" data-grade="easy" id="gradeEasy" type="button"></button>
      </div>
    </section>

    <section class="panel hidden" id="blocked">
      <h2 id="blockedTitle"></h2>
      <p class="lead" id="blockedLead"></p>
      <button class="btn primary" id="openBotBtn" type="button"></button>
    </section>

    <section class="panel hidden" id="finished">
      <h2 id="finishedTitle"></h2>
      <p class="lead"><span id="finishedLeadPrefix"></span> <span id="doneCount">0</span> <span id="finishedLeadSuffix"></span></p>
      <button class="btn primary" id="restartBtn" type="button"></button>
    </section>
  </main>

  <script>
    const API_BASE = 'https://api.intelahost.org';
    const gate = document.getElementById('gate');
    const trainer = document.getElementById('trainer');
    const blocked = document.getElementById('blocked');
    const finished = document.getElementById('finished');
    const startBtn = document.getElementById('startBtn');
    const startHint = document.getElementById('startHint');
    const openBotBtn = document.getElementById('openBotBtn');
    const restartBtn = document.getElementById('restartBtn');
    const revealBtn = document.getElementById('revealBtn');
    const ruText = document.getElementById('ruText');
    const srText = document.getElementById('srText');
    const cardCounter = document.getElementById('cardCounter');
    const sceneLabel = document.getElementById('sceneLabel');
    const playBtn = document.getElementById('playBtn');
    const doneCount = document.getElementById('doneCount');
    const grades = document.getElementById('grades');
    const gradeButtons = Array.from(document.querySelectorAll('.grade'));
    const gateTitle = document.getElementById('gateTitle');
    const gateLead = document.getElementById('gateLead');
    const gradeHard = document.getElementById('gradeHard');
    const gradeGood = document.getElementById('gradeGood');
    const gradeEasy = document.getElementById('gradeEasy');
    const blockedTitle = document.getElementById('blockedTitle');
    const blockedLead = document.getElementById('blockedLead');
    const finishedTitle = document.getElementById('finishedTitle');
    const finishedLeadPrefix = document.getElementById('finishedLeadPrefix');
    const finishedLeadSuffix = document.getElementById('finishedLeadSuffix');

    const tg = window.Telegram && window.Telegram.WebApp;
    const STORAGE_KEY = 'sc_miniapp_state_v1';
    const DATA_URL = 'data/srpski_cas.json?v=20260211-2';
    const SCENE_TITLE = '\u0420\u0435\u0441\u0442\u043e\u0440\u0430\u043d';
    const AUDIO_BASE = 'audio';
    const audioPlayer = new Audio();
    const BULLET = '\u2022';

    const ui = {
      gateTitle: '\u0423\u043d\u0438\u0432\u0435\u0440\u0441\u0430\u043b\u044c\u043d\u044b\u0439\u0020\u0443\u0440\u043e\u043a',
      gateLead: '\u0421\u043b\u0443\u0448\u0430\u0439\u0020\u2192\u0020\u043f\u043e\u0432\u0442\u043e\u0440\u044f\u0439\u0020\u2192\u0020\u043e\u0446\u0435\u043d\u0438\u0432\u0430\u0439\u002e\u0020\u041a\u043e\u0440\u043e\u0442\u043a\u0430\u044f\u0020\u0041\u0031\u002d\u0441\u0435\u0441\u0441\u0438\u044f\u002e',
      startHint: '\u041d\u0430\u0436\u043c\u0438\u0442\u0435\u0020\u0053\u0074\u0061\u0072\u0074\u002c\u0020\u0447\u0442\u043e\u0431\u044b\u0020\u0440\u0430\u0437\u0440\u0435\u0448\u0438\u0442\u044c\u0020\u0430\u0432\u0442\u043e\u0437\u0432\u0443\u043a\u002e',
      playLabel: '\u25b6\u0020\u0421\u043b\u0443\u0448\u0430\u0442\u044c',
      revealLabel: '\u041f\u043e\u043a\u0430\u0437\u0430\u0442\u044c\u0020\u043e\u0442\u0432\u0435\u0442',
      revealHideLabel: '\u0421\u043a\u0440\u044b\u0442\u044c\u0020\u043e\u0442\u0432\u0435\u0442',
      revealTextLabel: '\u041f\u043e\u043a\u0430\u0437\u0430\u0442\u044c\u0020\u0442\u0435\u043a\u0441\u0442',
      revealTextHideLabel: '\u0421\u043a\u0440\u044b\u0442\u044c\u0020\u0442\u0435\u043a\u0441\u0442',
      auditionHint: '\u041f\u0440\u043e\u0441\u043b\u0443\u0448\u0430\u0439\u0442\u0435\u0020\u0444\u0440\u0430\u0437\u0443',
      gradeHard: '\u0422\u044f\u0436\u0435\u043b\u043e',
      gradeGood: '\u0425\u043e\u0440\u043e\u0448\u043e',
      gradeEasy: '\u041b\u0435\u0433\u043a\u043e',
      blockedTitle: '\u0414\u043e\u0441\u0442\u0443\u043f\u0020\u043d\u0435\u0020\u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0451\u043d',
      blockedLead: '\u041e\u0442\u043a\u0440\u043e\u0439\u0442\u0435\u0020\u004d\u0069\u006e\u0069\u0020\u0041\u0070\u0070\u0020\u0447\u0435\u0440\u0435\u0437\u0020\u043a\u043d\u043e\u043f\u043a\u0443\u0020\u043c\u0435\u043d\u044e\u0020\u0432\u0020\u0447\u0430\u0442\u0435\u0020\u0431\u043e\u0442\u0430\u002e',
      openBot: '\u041e\u0442\u043a\u0440\u044b\u0442\u0020\u0431\u043e\u0442\u0430',
      finishedTitle: '\u0421\u0435\u0441\u0441\u0438\u044f\u0020\u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u0430',
      finishedLeadPrefix: '\u0412\u044b\u0020\u043f\u0440\u043e\u0448\u043b\u0438',
      finishedLeadSuffix: '\u0444\u0440\u0430\u0437\u002e',
      restart: '\u0415\u0449\u0451\u0020\u0440\u0430\u0437',
      loading: '\u0417\u0430\u0433\u0440\u0443\u0436\u0430\u0435\u043c\u0020\u043a\u0430\u0440\u0442\u043e\u0447\u043a\u0438\u2026',
      accessHint: '\u041e\u0442\u043a\u0440\u043e\u0439\u0442\u0435\u0020\u004d\u0069\u006e\u0069\u0020\u0041\u0070\u0070\u0020\u0447\u0435\u0440\u0435\u0437\u0020\u043a\u043d\u043e\u043f\u043a\u0443\u0020\u043c\u0435\u043d\u044e\u0020\u0432\u0020\u0054\u0065\u006c\u0065\u0067\u0072\u0061\u006d',
      accessDenied: '\u0414\u043e\u0441\u0442\u0443\u043f\u0020\u043d\u0435\u0020\u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0451\u043d',
    };

    function applyUiText() {
      gateTitle.textContent = ui.gateTitle;
      gateLead.textContent = ui.gateLead;
      startHint.textContent = ui.startHint;
      playBtn.textContent = ui.playLabel;
      revealBtn.textContent = ui.revealLabel;
      gradeHard.textContent = ui.gradeHard;
      gradeGood.textContent = ui.gradeGood;
      gradeEasy.textContent = ui.gradeEasy;
      blockedTitle.textContent = ui.blockedTitle;
      blockedLead.textContent = ui.blockedLead;
      openBotBtn.textContent = ui.openBot;
      finishedTitle.textContent = ui.finishedTitle;
      finishedLeadPrefix.textContent = ui.finishedLeadPrefix;
      finishedLeadSuffix.textContent = ui.finishedLeadSuffix;
      restartBtn.textContent = ui.restart;
    }

    applyUiText();

    let deck = [];

    const state = {
      accessOk: false,
      index: 0,
      revealed: false,
      started: false,
      audioUrl: '',
      deckReady: false,
    };

    function show(el) {
      el.classList.remove('hidden');
    }

    function hide(el) {
      el.classList.add('hidden');
    }

    function setAccess(ok, message) {
      state.accessOk = ok;
      if (ok) {
        startBtn.disabled = false;
        show(gate);
        hide(blocked);
      } else {
        startBtn.disabled = true;
        hide(trainer);
        hide(finished);
        hide(gate);
        show(blocked);
      }
      if (message && !ok) {
        startHint.textContent = message;
      }
    }

    function setGradesEnabled(enabled) {
      gradeButtons.forEach((btn) => {
        btn.disabled = !enabled;
      });
      grades.classList.toggle('hidden', !enabled);
    }

    function renderCard() {
      if (!deck.length) {
        ruText.textContent = ui.loading;
        srText.textContent = '';
        playBtn.disabled = true;
        setGradesEnabled(false);
        return;
      }
      const item = deck[state.index];
      if (!item) {
        showFinished();
        return;
      }
      const isReverse = item.direction === 'reverse';
      const isAudition = item.mode === 'audition';
      if (isAudition && !state.revealed) {
        ruText.textContent = ui.auditionHint;
        srText.textContent = '';
      } else {
        ruText.textContent = isReverse ? item.sr : item.ru;
        srText.textContent = isReverse ? item.ru : item.sr;
      }
      sceneLabel.textContent = `A1 ${BULLET} ${SCENE_TITLE}`;
      cardCounter.textContent = `${state.index + 1}/${deck.length}`;
      srText.classList.toggle('hidden', !state.revealed);
      if (state.revealed) {
        revealBtn.textContent = isAudition ? ui.revealTextHideLabel : ui.revealHideLabel;
      } else {
        revealBtn.textContent = isAudition ? ui.revealTextLabel : ui.revealLabel;
      }
      state.audioUrl = resolveAudioUrl(item);
      playBtn.disabled = !state.audioUrl;
      setGradesEnabled(state.revealed && !isAudition);
      saveState();
    }

    function showFinished() {
      doneCount.textContent = `${deck.length}`;
      hide(trainer);
      show(finished);
      saveState();
    }

    function advanceCard() {
      const nextIndex = Math.min(state.index + 1, deck.length);
      state.index = nextIndex;
      state.revealed = false;
      renderCard();
      playAudio();
    }

    function playAudio() {
      if (!state.started) {
        return;
      }
      if (!state.audioUrl) {
        return;
      }
      if (tg && tg.HapticFeedback) {
        tg.HapticFeedback.impactOccurred('light');
      }
      audioPlayer.pause();
      audioPlayer.src = state.audioUrl;
      audioPlayer.currentTime = 0;
      audioPlayer.play().catch(() => {
        // ignore
      });
    }

    function startSession(reset) {
      state.started = true;
      if (reset) {
        state.index = 0;
      }
      state.revealed = false;
      hide(gate);
      hide(finished);
      if (state.index >= deck.length) {
        showFinished();
        return;
      }
      show(trainer);
      renderCard();
      playAudio();
    }

    startBtn.addEventListener('click', () => {
      if (!state.accessOk) {
        return;
      }
      if (tg && tg.ready) {
        tg.ready();
      }
      startSession(false);
    });

    revealBtn.addEventListener('click', () => {
      state.revealed = !state.revealed;
      renderCard();
    });

    gradeButtons.forEach((btn) => {
      btn.addEventListener('click', () => {
        if (!state.revealed) {
          return;
        }
        advanceCard();
      });
    });

    playBtn.addEventListener('click', () => {
      playAudio();
    });

    restartBtn.addEventListener('click', () => {
      startSession(true);
    });

    openBotBtn.addEventListener('click', () => {
      const url = 'https://t.me/SrpskiCas_bot';
      if (tg && tg.openTelegramLink) {
        tg.openTelegramLink(url);
      } else {
        window.location.href = url;
      }
    });

    function getInitData() {
      if (tg && tg.initData) {
        return tg.initData;
      }
      const hash = window.location.hash.startsWith('#') ? window.location.hash.slice(1) : '';
      const search = window.location.search.startsWith('?') ? window.location.search.slice(1) : '';
      const params = new URLSearchParams(hash || search);
      const raw = params.get('tgWebAppData') || '';
      return raw ? decodeURIComponent(raw) : '';
    }

    const initData = getInitData();

    if (tg && tg.ready) {
      tg.ready();
    }

    function loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) {
          return;
        }
        const saved = JSON.parse(raw);
        if (Number.isInteger(saved.index)) {
          state.index = Math.min(Math.max(saved.index, 0), deck.length);
        }
      } catch (err) {
        // ignore
      }
    }

    function saveState() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify({ index: state.index }));
      } catch (err) {
        // ignore
      }
    }

    function resolveAudioUrl(item) {
      if (!AUDIO_BASE || !item || !item.audio) {
        return '';
      }
      return `${AUDIO_BASE}/${item.audio}`;
    }

    function extractLevel(cardId) {
      const raw = String(cardId || '');
      const m = raw.match(/^(A1|A2|B1|B2)_/);
      return m ? m[1] : 'A1';
    }

    function shuffle(arr) {
      const out = arr.slice();
      for (let i = out.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [out[i], out[j]] = [out[j], out[i]];
      }
      return out;
    }

    function buildLesson(cards) {
      if (!cards.length) {
        return [];
      }
      const level = extractLevel(cards[0].id);
      const cfg = {
        A1: { minutes: 20, secPerCard: 35, aud: 0.40, srsDirect: 0.28, srsReverse: 0.07, qa: 0.15, dialog: 0.10 },
        A2: { minutes: 25, secPerCard: 35, aud: 0.30, srsDirect: 0.28, srsReverse: 0.12, qa: 0.20, dialog: 0.10 },
        B1: { minutes: 30, secPerCard: 40, aud: 0.15, srsDirect: 0.21, srsReverse: 0.14, qa: 0.25, dialog: 0.25 },
        B2: { minutes: 35, secPerCard: 40, aud: 0.10, srsDirect: 0.15, srsReverse: 0.15, qa: 0.25, dialog: 0.35 },
      }[level] || { minutes: 20, secPerCard: 35, aud: 0.40, srsDirect: 0.28, srsReverse: 0.07, qa: 0.15, dialog: 0.10 };

      const total = Math.max(1, Math.floor((cfg.minutes * 60) / cfg.secPerCard));
      const directPool = cards.filter((c) => c.direction !== 'reverse');
      const reversePool = cards.filter((c) => c.direction === 'reverse');

      let audCount = Math.round(total * cfg.aud);
      let srsDirectCount = Math.round(total * cfg.srsDirect);
      let srsReverseCount = Math.round(total * cfg.srsReverse);
      const dialogAvailable = false;

      if (!dialogAvailable) {
        const freed = Math.round(total * (cfg.qa + cfg.dialog));
        const addToAud = Math.round(freed * 0.4);
        const addToSrs = Math.max(0, freed - addToAud);
        audCount += addToAud;
        srsDirectCount += addToSrs;
      }

      const used = new Set();
      const audition = [];
      const srsDirect = [];
      const srsReverse = [];

      shuffle(directPool).forEach((card) => {
        if (audition.length < audCount) {
          audition.push({ ...card, mode: 'audition' });
          used.add(card.id);
        }
      });

      shuffle(directPool).forEach((card) => {
        if (srsDirect.length >= srsDirectCount) {
          return;
        }
        if (used.has(card.id)) {
          return;
        }
        srsDirect.push({ ...card, mode: 'srs' });
        used.add(card.id);
      });

      shuffle(reversePool).forEach((card) => {
        if (srsReverse.length < srsReverseCount) {
          srsReverse.push({ ...card, mode: 'srs' });
        }
      });

      return audition.concat(srsDirect, srsReverse);
    }

    async function loadDeck() {
      try {
        const res = await fetch(DATA_URL);
        if (!res.ok) {
          throw new Error(`deck load failed: ${res.status}`);
        }
        const data = await res.json();
        const items = Array.isArray(data) ? data : (data.cards || []);
        const base = items
          .map((item) => {
            const tags = String(item.tags || '');
            const direction = item.direction || (tags.includes('direction:reverse') ? 'reverse' : 'direct');
            return {
              id: item.card_id || item.id || '',
              ru: item.ru_text || '',
              sr: item.sr_text || '',
              audio: item.audio_sr_file || item.audio || '',
              direction,
            };
          })
          .filter((item) => item.ru && item.sr && item.audio)
          .slice(0, 200);
        deck = buildLesson(base);
        state.deckReady = deck.length > 0;
      } catch (err) {
        deck = [];
        state.deckReady = false;
      }
      if (state.index >= deck.length) {
        state.index = 0;
      }
      if (state.accessOk && state.deckReady) {
        startBtn.disabled = false;
      }
      renderCard();
    }

    loadState();
    loadDeck();

    if (!initData) {
      setAccess(false, ui.accessHint);
    } else {
      fetch(`${API_BASE}/access?initData=${encodeURIComponent(initData)}`)
        .then(async (r) => {
          const data = await r.json().catch(() => ({}));
          if (!r.ok || !data || !data.ok) {
            const reason = data && data.detail ? data.detail : ui.accessDenied;
            throw new Error(reason);
          }
          setAccess(true);
          if (state.deckReady) {
            startBtn.disabled = false;
          }
        })
        .catch((err) => {
          setAccess(false, `${ui.accessDenied}: ${err.message}`);
        });
    }
  </script>
</body>
</html>
