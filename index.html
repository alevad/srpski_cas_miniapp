<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Srpski_Cas Mini App</title>
  <style>
    .hidden { display: none !important; }
  </style>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="styles.css?v=20260210-14" />
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
  <main class="app">
    <header class="app-bar">
      <div class="app-brand">
        <img class="brand-logo" src="assets/logo.png" alt="Srpski_Cas" />
      </div>
    </header>

    <div class="progress" id="progress">
      <div class="progress-row">
        <span id="sceneLabel">A1</span>
        <span id="cardCounter">0/0</span>
      </div>
      <div class="progress-row">
        <span id="blockLabel">&nbsp;</span>
      </div>
    </div>

    <section class="panel" id="gate">
      <div class="gate-stack">
        <h1 id="gateTitle"></h1>
        <p class="lead" id="gateLead"></p>
      <div class="block-intro">
        <div class="block-title" id="blockGateTitle"></div>
        <div class="block-desc" id="blockGateDesc"></div>
        <div class="block-spacer" id="blockGateSpacer" aria-hidden="true"></div>
      </div>
        <button class="btn primary" id="startBtn" type="button" disabled>Start</button>
        <div class="hint" id="startHint"></div>
      </div>
    </section>

    <section class="panel hidden" id="trainer">
      <div class="trainer-stack">
        <div class="phrase" id="ruText"></div>
        <button class="btn play" id="playBtn" type="button"></button>
        <button class="btn ghost" id="revealBtn" type="button"></button>
        <div class="answer hidden" id="srText"></div>
        <button class="btn ghost hidden" id="nextBtn" type="button"></button>
        <div class="grades hidden" id="grades">
          <button class="grade hard" data-grade="hard" id="gradeHard" type="button"></button>
          <button class="grade good" data-grade="good" id="gradeGood" type="button"></button>
          <button class="grade easy" data-grade="easy" id="gradeEasy" type="button"></button>
        </div>
      </div>
    </section>

    <section class="panel hidden" id="blocked">
      <h2 id="blockedTitle"></h2>
      <p class="lead" id="blockedLead"></p>
      <button class="btn primary" id="openBotBtn" type="button"></button>
    </section>

    <section class="panel hidden" id="finished">
      <h2 id="finishedTitle"></h2>
      <p class="lead"><span id="finishedLeadPrefix"></span> <span id="doneCount">0</span> <span id="finishedLeadSuffix"></span></p>
      <button class="btn primary" id="restartBtn" type="button"></button>
    </section>
  </main>

  <script>
    const API_BASE = 'https://api.intelahost.org';
    const gate = document.getElementById('gate');
    const trainer = document.getElementById('trainer');
    const blocked = document.getElementById('blocked');
    const finished = document.getElementById('finished');
    const startBtn = document.getElementById('startBtn');
    const startHint = document.getElementById('startHint');
    const openBotBtn = document.getElementById('openBotBtn');
    const restartBtn = document.getElementById('restartBtn');
    const revealBtn = document.getElementById('revealBtn');
    const ruText = document.getElementById('ruText');
    const srText = document.getElementById('srText');
    const cardCounter = document.getElementById('cardCounter');
    const sceneLabel = document.getElementById('sceneLabel');
    const blockLabel = document.getElementById('blockLabel');
    const playBtn = document.getElementById('playBtn');
    const nextBtn = document.getElementById('nextBtn');
    const doneCount = document.getElementById('doneCount');
    const grades = document.getElementById('grades');
    const gradeButtons = Array.from(document.querySelectorAll('.grade'));
    const gateTitle = document.getElementById('gateTitle');
    const gateLead = document.getElementById('gateLead');
    const blockGateTitle = document.getElementById('blockGateTitle');
    const blockGateDesc = document.getElementById('blockGateDesc');
    const gradeHard = document.getElementById('gradeHard');
    const gradeGood = document.getElementById('gradeGood');
    const gradeEasy = document.getElementById('gradeEasy');
    const blockedTitle = document.getElementById('blockedTitle');
    const blockedLead = document.getElementById('blockedLead');
    const finishedTitle = document.getElementById('finishedTitle');
    const finishedLeadPrefix = document.getElementById('finishedLeadPrefix');
    const finishedLeadSuffix = document.getElementById('finishedLeadSuffix');

    const tg = window.Telegram && window.Telegram.WebApp;
    const STORAGE_KEY = 'sc_miniapp_state_v1';
    const DATA_URL = 'data/srpski_cas.json?v=20260211-2';
    const SCENE_TITLE = '\u0420\u0435\u0441\u0442\u043e\u0440\u0430\u043d';
    const AUDIO_BASE = 'audio';
    const audioPlayer = new Audio();
    const BULLET = '\u2022';

    const ui = {
      gateTitle: '',
      gateLead: '',
      startHint: '',
      playLabel: '\u25b6\u0020\u0421\u043b\u0443\u0448\u0430\u0442\u044c',
      revealLabel: '\u041f\u043e\u043a\u0430\u0437\u0430\u0442\u044c\u0020\u043e\u0442\u0432\u0435\u0442',
      revealHideLabel: '\u0421\u043a\u0440\u044b\u0442\u044c\u0020\u043e\u0442\u0432\u0435\u0442',
      revealTextLabel: '\u041f\u043e\u043a\u0430\u0437\u0430\u0442\u044c\u0020\u0442\u0435\u043a\u0441\u0442',
      revealTextHideLabel: '\u0421\u043a\u0440\u044b\u0442\u044c\u0020\u0442\u0435\u043a\u0441\u0442',
      auditionHint: '\u041f\u0440\u043e\u0441\u043b\u0443\u0448\u0430\u0439\u0442\u0435\u0020\u0444\u0440\u0430\u0437\u0443',
      nextLabel: '\u0414\u0430\u043b\u044c\u0448\u0435',
      gradeHard: '\u0422\u044f\u0436\u0435\u043b\u043e',
      gradeGood: '\u0425\u043e\u0440\u043e\u0448\u043e',
      gradeEasy: '\u041b\u0435\u0433\u043a\u043e',
      blockedTitle: '\u0414\u043e\u0441\u0442\u0443\u043f\u0020\u043d\u0435\u0020\u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0451\u043d',
      blockedLead: '\u041e\u0442\u043a\u0440\u043e\u0439\u0442\u0435\u0020\u004d\u0069\u006e\u0069\u0020\u0041\u0070\u0070\u0020\u0447\u0435\u0440\u0435\u0437\u0020\u043a\u043d\u043e\u043f\u043a\u0443\u0020\u043c\u0435\u043d\u044e\u0020\u0432\u0020\u0447\u0430\u0442\u0435\u0020\u0431\u043e\u0442\u0430\u002e',
      openBot: '\u041e\u0442\u043a\u0440\u044b\u0442\u0020\u0431\u043e\u0442\u0430',
      finishedTitle: '\u0421\u0435\u0441\u0441\u0438\u044f\u0020\u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u0430',
      finishedLeadPrefix: '\u0412\u044b\u0020\u043f\u0440\u043e\u0448\u043b\u0438',
      finishedLeadSuffix: '\u0444\u0440\u0430\u0437\u002e',
      restart: '\u0415\u0449\u0451\u0020\u0440\u0430\u0437',
      loading: '\u0417\u0430\u0433\u0440\u0443\u0436\u0430\u0435\u043c\u0020\u043a\u0430\u0440\u0442\u043e\u0447\u043a\u0438\u2026',
      accessHint: '\u041e\u0442\u043a\u0440\u043e\u0439\u0442\u0435\u0020\u004d\u0069\u006e\u0069\u0020\u0041\u0070\u0070\u0020\u0447\u0435\u0440\u0435\u0437\u0020\u043a\u043d\u043e\u043f\u043a\u0443\u0020\u043c\u0435\u043d\u044e\u0020\u0432\u0020\u0054\u0065\u006c\u0065\u0067\u0072\u0061\u006d',
      accessDenied: '\u0414\u043e\u0441\u0442\u0443\u043f\u0020\u043d\u0435\u0020\u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0451\u043d',
    };

    function applyUiText() {
      gateTitle.textContent = ui.gateTitle;
      gateTitle.classList.toggle('hidden', !ui.gateTitle);
      gateLead.textContent = ui.gateLead;
      startHint.textContent = ui.startHint;
      blockGateTitle.textContent = '';
      blockGateDesc.textContent = '';
      playBtn.textContent = ui.playLabel;
      revealBtn.textContent = ui.revealLabel;
      nextBtn.textContent = ui.nextLabel;
      gradeHard.textContent = ui.gradeHard;
      gradeGood.textContent = ui.gradeGood;
      gradeEasy.textContent = ui.gradeEasy;
      blockedTitle.textContent = ui.blockedTitle;
      blockedLead.textContent = ui.blockedLead;
      openBotBtn.textContent = ui.openBot;
      finishedTitle.textContent = ui.finishedTitle;
      finishedLeadPrefix.textContent = ui.finishedLeadPrefix;
      finishedLeadSuffix.textContent = ui.finishedLeadSuffix;
      restartBtn.textContent = ui.restart;
    }

    applyUiText();

    let deck = [];

    const state = {
      accessOk: false,
      index: 0,
      revealed: false,
      started: false,
      blockIntro: true,
      audioUrl: '',
      deckReady: false,
    };

    function show(el) {
      el.classList.remove('hidden');
    }

    function hide(el) {
      el.classList.add('hidden');
    }

    function setAccess(ok, message) {
      state.accessOk = ok;
      if (ok) {
        startBtn.disabled = false;
        show(gate);
        hide(blocked);
      } else {
        startBtn.disabled = true;
        hide(trainer);
        hide(finished);
        hide(gate);
        show(blocked);
      }
      if (message && !ok) {
        startHint.textContent = message;
      }
    }

    function setGradesEnabled(enabled) {
      gradeButtons.forEach((btn) => {
        btn.disabled = !enabled;
      });
      grades.classList.toggle('hidden', !enabled);
    }

    function showBlockIntro(item) {
      state.blockIntro = true;
      gateTitle.textContent = ui.gateTitle;
      gateLead.textContent = ui.gateLead;
      const gateTitleText = (item && item.blockTitle) ? item.blockTitle : '';
      blockGateTitle.textContent = gateTitleText;
      blockGateDesc.textContent = (item && item.blockDesc) ? item.blockDesc : '';
      blockGateTitle.classList.toggle('hidden', !gateTitleText);
      show(gate);
      hide(trainer);
      hide(finished);
      if (state.accessOk && state.deckReady) {
        startBtn.disabled = false;
      }
    }

    function renderCard() {
      if (!deck.length) {
        ruText.textContent = ui.loading;
        srText.textContent = '';
        playBtn.disabled = true;
        setGradesEnabled(false);
        return;
      }
      const item = deck[state.index];
      if (!item) {
        showFinished();
        return;
      }
      const isReverse = item.direction === 'reverse';
      const isAudition = item.mode === 'audition';
      const fallbackBlock = isAudition
        ? 'Аудирование'
        : (item.mode === 'qa'
          ? 'Вопрос-ответ'
          : (item.mode === 'dialog'
            ? 'Диалог'
            : (isReverse ? 'SRS Sr\u2192Ru' : 'SRS Ru\u2192Sr')));
      const blockName = item.blockTitle || fallbackBlock;
      if (isAudition && !state.revealed) {
        ruText.textContent = ui.auditionHint;
        srText.textContent = '';
      } else {
        let prompt = item.ru;
        let answer = item.sr;
        if (item.mode === 'audition') {
          prompt = item.sr;
          answer = item.ru;
        } else if (item.mode === 'qa' || item.mode === 'dialog' || isReverse) {
          prompt = item.sr;
          answer = item.ru;
        }
        ruText.textContent = prompt;
        srText.textContent = answer;
      }
      sceneLabel.textContent = `A1 ${BULLET} ${SCENE_TITLE}`;
      cardCounter.textContent = `${state.index + 1}/${deck.length}`;
      blockLabel.textContent = blockName;
      srText.classList.toggle('hidden', !state.revealed);
      if (state.revealed) {
        revealBtn.textContent = isAudition ? ui.revealTextHideLabel : ui.revealHideLabel;
      } else {
        revealBtn.textContent = isAudition ? ui.revealTextLabel : ui.revealLabel;
      }
      state.audioUrl = resolveAudioUrl(item, 'sr');
      playBtn.disabled = !state.audioUrl;
      const showGrades = state.revealed && (item.mode === 'srs' || item.mode === 'qa' || (item.mode === 'dialog' && item.dialogEnd));
      setGradesEnabled(showGrades);
      const showNext = item.mode === 'audition' && state.revealed;
      nextBtn.classList.toggle('hidden', !showNext);
      saveState();
    }

    function showFinished() {
      doneCount.textContent = `${deck.length}`;
      hide(trainer);
      show(finished);
      saveState();
    }

    function advanceCard() {
      const nextIndex = Math.min(state.index + 1, deck.length);
      state.index = nextIndex;
      state.revealed = false;
      const nextItem = deck[state.index];
      if (nextItem && nextItem.blockStart && state.started) {
        showBlockIntro(nextItem);
        return;
      }
      renderCard();
      playAutoAudio();
    }

    function playAudio(force = false, lang = 'sr') {
      if (!state.started) {
        return;
      }
      const item = deck[state.index];
      if (!item) {
        return;
      }
      if (!force && item.mode !== 'audition') {
        return;
      }
      const url = resolveAudioUrl(item, lang);
      if (!url) {
        return;
      }
      if (tg && tg.HapticFeedback) {
        tg.HapticFeedback.impactOccurred('light');
      }
      audioPlayer.pause();
      audioPlayer.src = url;
      audioPlayer.currentTime = 0;
      audioPlayer.play().catch(() => {
        // ignore
      });
    }

    function playAutoAudio() {
      if (!state.started) {
        return;
      }
      const item = deck[state.index];
      if (!item) {
        return;
      }
      if (item.mode === 'audition') {
        playAudio(true, 'sr');
        return;
      }
      if (item.mode === 'srs') {
        const lang = item.direction === 'reverse' ? 'sr' : 'ru';
        playAudio(true, lang);
      }
    }

    function startSession(reset) {
      state.started = true;
      state.blockIntro = false;
      if (reset) {
        state.index = 0;
      }
      state.revealed = false;
      hide(gate);
      hide(finished);
      if (state.index >= deck.length) {
        showFinished();
        return;
      }
      show(trainer);
      renderCard();
      playAutoAudio();
    }

    startBtn.addEventListener('click', () => {
      if (!state.accessOk) {
        return;
      }
      if (tg && tg.ready) {
        tg.ready();
      }
      startSession(false);
    });

    revealBtn.addEventListener('click', () => {
      const item = deck[state.index];
      if (item && state.revealed) {
        if (item.mode === 'dialog' && !item.dialogEnd) {
          advanceCard();
          return;
        }
      }
      state.revealed = !state.revealed;
      renderCard();
      if (item && state.revealed && item.mode === 'srs') {
        const lang = item.direction === 'reverse' ? 'ru' : 'sr';
        playAudio(true, lang);
      }
    });

    gradeButtons.forEach((btn) => {
      btn.addEventListener('click', () => {
        if (!state.revealed) {
          return;
        }
        advanceCard();
      });
    });

    playBtn.addEventListener('click', () => {
      playAudio(true);
    });

    nextBtn.addEventListener('click', () => {
      advanceCard();
    });

    restartBtn.addEventListener('click', () => {
      startSession(true);
    });

    openBotBtn.addEventListener('click', () => {
      const url = 'https://t.me/SrpskiCas_bot';
      if (tg && tg.openTelegramLink) {
        tg.openTelegramLink(url);
      } else {
        window.location.href = url;
      }
    });

    function getInitData() {
      if (tg && tg.initData) {
        return tg.initData;
      }
      const hash = window.location.hash.startsWith('#') ? window.location.hash.slice(1) : '';
      const search = window.location.search.startsWith('?') ? window.location.search.slice(1) : '';
      const params = new URLSearchParams(hash || search);
      const raw = params.get('tgWebAppData') || '';
      return raw ? decodeURIComponent(raw) : '';
    }

    const initData = getInitData();

    if (tg && tg.ready) {
      tg.ready();
    }

    function loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) {
          return;
        }
        const saved = JSON.parse(raw);
        if (Number.isInteger(saved.index)) {
          state.index = Math.min(Math.max(saved.index, 0), deck.length);
        }
      } catch (err) {
        // ignore
      }
    }

    function saveState() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify({ index: state.index }));
      } catch (err) {
        // ignore
      }
    }

    function resolveAudioUrl(item, lang) {
      if (!AUDIO_BASE || !item) {
        return '';
      }
      const name = lang === 'ru' ? item.audioRu : item.audioSr;
      if (!name) {
        return '';
      }
      return `${AUDIO_BASE}/${name}`;
    }

    function extractLevel(cardId) {
      const raw = String(cardId || '');
      const m = raw.match(/^(A1|A2|B1|B2)_/);
      return m ? m[1] : 'A1';
    }

    function shuffle(arr) {
      const out = arr.slice();
      for (let i = out.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [out[i], out[j]] = [out[j], out[i]];
      }
      return out;
    }

    function buildDialogGroups(cards) {
      const groups = new Map();
      cards.forEach((card) => {
        if (card.kind !== 'dlg_line' || !card.dlgGroup) {
          return;
        }
        if (!groups.has(card.dlgGroup)) {
          groups.set(card.dlgGroup, []);
        }
        groups.get(card.dlgGroup).push(card);
      });
      const out = [];
      groups.forEach((items) => {
        const sorted = items.slice().sort((a, b) => {
          const ao = Number.isFinite(a.order) ? a.order : 0;
          const bo = Number.isFinite(b.order) ? b.order : 0;
          if (ao !== bo) {
            return ao - bo;
          }
          return String(a.id).localeCompare(String(b.id));
        });
        if (sorted.length >= 2) {
          out.push(sorted);
        }
      });
      return out;
    }

    const blockMeta = {
      audition: {
        title: '',
        desc: '\u0421\u043d\u0430\u0447\u0430\u043b\u0430 \u043f\u043e\u0441\u043b\u0443\u0448\u0430\u0442\u044c, \u043f\u043e\u0442\u043e\u043c \u043f\u043e\u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c \u0442\u0435\u043a\u0441\u0442.',
      },
      srsDirect: {
        title: '',
        desc: '\u041f\u0435\u0440\u0435\u0432\u0435\u0434\u0438 \u0444\u0440\u0430\u0437\u0443 \u043d\u0430 \u0441\u0435\u0440\u0431\u0441\u043a\u0438\u0439 \u0438 \u043e\u0446\u0435\u043d\u0438, \u043d\u0430\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043b\u0435\u0433\u043a\u043e \u0438 \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e \u044d\u0442\u043e \u043f\u043e\u043b\u0443\u0447\u0438\u043b\u043e\u0441\u044c',
      },
      srsReverse: {
        title: '',
        desc: '\u041f\u0435\u0440\u0435\u0432\u0435\u0434\u0438 \u0444\u0440\u0430\u0437\u0443 \u043d\u0430 \u0440\u0443\u0441\u0441\u043a\u0438\u0439 \u0438 \u043e\u0446\u0435\u043d\u0438, \u043d\u0430\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043b\u0435\u0433\u043a\u043e \u0438 \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e \u044d\u0442\u043e \u043f\u043e\u043b\u0443\u0447\u0438\u043b\u043e\u0441\u044c',
      },
      qa: {
        title: '',
        desc: '\u0421\u043b\u0443\u0448\u0430\u0435\u043c \u0432\u043e\u043f\u0440\u043e\u0441 \u0438 \u043e\u0442\u0432\u0435\u0447\u0430\u0435\u043c \u0443\u0441\u0442\u043d\u043e.',
      },
      dialog: {
        title: '',
        desc: '\u0421\u0435\u0440\u0438\u044f \u0440\u0435\u043f\u043b\u0438\u043a, \u043e\u0446\u0435\u043d\u043a\u0430 \u0432 \u043a\u043e\u043d\u0446\u0435.',
      },
    };

    function annotateBlock(items, key) {
      const meta = blockMeta[key] || { title: '', desc: '' };
      return items.map((item, idx) => ({
        ...item,
        blockKey: key,
        blockTitle: meta.title,
        blockDesc: meta.desc,
        blockStart: idx === 0,
      }));
    }

    function buildLesson(cards) {
      if (!cards.length) {
        return [];
      }
      const level = extractLevel(cards[0].id);
      const cfg = {
        A1: { minutes: 20, secPerCard: 25, aud: 0.20, srsDirect: 0.50, srsReverse: 0.20, qa: 0.05, dialog: 0.05 },
        A2: { minutes: 25, secPerCard: 25, aud: 0.20, srsDirect: 0.40, srsReverse: 0.10, qa: 0.20, dialog: 0.10 },
        B1: { minutes: 30, secPerCard: 25, aud: 0.15, srsDirect: 0.21, srsReverse: 0.14, qa: 0.25, dialog: 0.25 },
        B2: { minutes: 35, secPerCard: 25, aud: 0.10, srsDirect: 0.15, srsReverse: 0.15, qa: 0.25, dialog: 0.35 },
      }[level] || { minutes: 20, secPerCard: 25, aud: 0.20, srsDirect: 0.50, srsReverse: 0.20, qa: 0.05, dialog: 0.05 };

      const total = Math.max(1, Math.floor((cfg.minutes * 60) / cfg.secPerCard));
      const singlePool = cards.filter((c) => c.kind !== 'dlg_line');
      const directPool = singlePool.filter((c) => c.direction !== 'reverse');
      const reversePool = singlePool.filter((c) => c.direction === 'reverse');
      const dialogGroups = buildDialogGroups(cards);
      const qaGroup = dialogGroups[0] || null;
      const dialogGroup = dialogGroups.length > 1 ? dialogGroups[1] : null;

      let audCount = Math.round(total * cfg.aud);
      let srsDirectCount = Math.round(total * cfg.srsDirect);
      let srsReverseCount = Math.round(total * cfg.srsReverse);

      const hasQa = Boolean(qaGroup);
      const hasDialog = Boolean(dialogGroup);
      if (!hasQa || !hasDialog) {
        const missingShare = (hasQa ? 0 : cfg.qa) + (hasDialog ? 0 : cfg.dialog);
        if (missingShare > 0) {
          const freed = Math.round(total * missingShare);
          srsReverseCount += freed;
        }
      }

      if (reversePool.length > 0 && srsReverseCount < 1) {
        srsReverseCount = 1;
      }

      const used = new Set();
      const audition = [];
      const srsDirect = [];
      const srsReverse = [];

      shuffle(directPool).forEach((card) => {
        if (audition.length < audCount) {
          audition.push({ ...card, mode: 'audition' });
          used.add(card.id);
        }
      });

      shuffle(directPool).forEach((card) => {
        if (srsDirect.length >= srsDirectCount) {
          return;
        }
        if (used.has(card.id)) {
          return;
        }
        srsDirect.push({ ...card, mode: 'srs' });
        used.add(card.id);
      });

      shuffle(reversePool).forEach((card) => {
        if (srsReverse.length < srsReverseCount) {
          srsReverse.push({ ...card, mode: 'srs' });
        }
      });

      const qa = hasQa ? qaGroup.map((c) => ({ ...c, mode: 'qa' })) : [];
      const dialog = hasDialog
        ? dialogGroup.map((c, idx) => ({ ...c, mode: 'dialog', dialogEnd: idx === dialogGroup.length - 1 }))
        : [];
      const auditionBlock = annotateBlock(audition, 'audition');
      const srsDirectBlock = annotateBlock(srsDirect, 'srsDirect');
      const srsReverseBlock = annotateBlock(srsReverse, 'srsReverse');
      const qaBlock = annotateBlock(qa, 'qa');
      const dialogBlock = annotateBlock(dialog, 'dialog');
      return auditionBlock.concat(srsDirectBlock, srsReverseBlock, qaBlock, dialogBlock);
    }

    async function loadDeck() {
      try {
        const res = await fetch(DATA_URL);
        if (!res.ok) {
          throw new Error(`deck load failed: ${res.status}`);
        }
        const data = await res.json();
        const items = Array.isArray(data) ? data : (data.cards || []);
        const base = items
          .map((item) => {
            const tags = String(item.tags || '');
            const direction = item.direction || (tags.includes('direction:reverse') ? 'reverse' : 'direct');
            return {
              id: item.card_id || item.id || '',
              ru: item.ru_text || '',
              sr: item.sr_text || '',
              audioSr: item.audio_sr_file || item.audio || '',
              audioRu: item.audio_ru_file || '',
              direction,
              kind: item.kind || '',
              dlgGroup: item.dlg_group_id || '',
              dlgRole: item.dlg_role || '',
              order: Number.isFinite(Number(item.order)) ? Number(item.order) : null,
            };
          })
          .filter((item) => item.ru && item.sr && item.audioSr)
          .slice(0, 200);
        deck = buildLesson(base);
        state.deckReady = deck.length > 0;
        if (state.deckReady) {
          showBlockIntro(deck[0]);
        }
      } catch (err) {
        deck = [];
        state.deckReady = false;
      }
      if (state.index >= deck.length) {
        state.index = 0;
      }
      if (state.accessOk && state.deckReady) {
        startBtn.disabled = false;
      }
      renderCard();
    }

    loadState();
    loadDeck();

    if (!initData) {
      setAccess(false, ui.accessHint);
    } else {
      fetch(`${API_BASE}/access?initData=${encodeURIComponent(initData)}`)
        .then(async (r) => {
          const data = await r.json().catch(() => ({}));
          if (!r.ok || !data || !data.ok) {
            const reason = data && data.detail ? data.detail : ui.accessDenied;
            throw new Error(reason);
          }
          setAccess(true);
          if (state.deckReady) {
            startBtn.disabled = false;
          }
        })
        .catch((err) => {
          setAccess(false, `${ui.accessDenied}: ${err.message}`);
        });
    }
  </script>
</body>
</html>
